# Author: Akira Kudo
# Created: 2024/03/19
# Last Updated: 2024/05/15

import os
from typing import List

from feature_extraction.extract_label_and_feature_from_csv import extract_label_and_feature_from_csv
from feature_extraction.extract_pregenerated_labels_and_compute_features import extract_pregenerated_labels_and_compute_features

POSE = list(range(3*6)) # <- 3 (x,y,lhl) columns x 6 body parts
# 6 bodyparts: snout, rightfrontpaw, leftfrontpaw, righthindpaw, lefthindpaw, tailbase; [belly]

def do_feature_extraction(csv_path : str,
                          predictions_path : str,
                          clf_sav_path : str,
                          computed_feature_saving_path : str,
                          fps : int=40,
                          brute_thresholding : bool=False, 
                          threshold : float=0.8,
                          recompute : bool=False,
                          save_result : bool=True,
                          pose : List[int]=POSE
                          ):
    """
    Execute feature extraction on a csv, returning the obtained labels & csvs.

    :param str csv_path: A dlc csv holding body part movement data.
    :param str predictions_path: Path to predictions file generated by
    a B-SOID network.
    :param str clf_sav_path: Path to a B-SOID random forest classifier
    we use to extract features. 
    :param str computed_feature_saving_path: Path to where we save the 
    computed features & labels & csv. 
    :param int fps: Frame per second used to record the csv_path file, default=40.
    :param bool brute_thresholding: Whether to use brute thresholding when filtering for
    extracted B-SOID features. Only guaranteed if recompute is True, and defauls to false.
    :param float threshold: Threshold when brute thresholding is done. Only guaranteed 
    if recompute is True, and defaults to 0.8.
    :param bool recompute: Whether to recompute if prior results are found, default=False.
    :param bool save_result: Whether to save computation results, default=True.
    :param List[int] pose: List of column index to extract from dlc csv. Often extract
    num_bodypart x 3 (x,y,likelihood) values . Defaults to POSE, every body part but belly.

    :returns np.ndarray labels: Extracted labels.
    :returns np.ndarray features: Extracted features.
    """
    labels, features = None, None
    if not recompute:
        print("Attempting fetch of previous results, brute_thresholding and threshold " + 
              "aren't guaranteed to have meaning.")

    if predictions_path is not None and not recompute:
        print("Extracting pregenerated labels and computing features!")
        labels, features = extract_pregenerated_labels_and_compute_features(
            predictions_path, os.path.basename(csv_path), 
            clf_sav_path=clf_sav_path, fps=fps,
            save_result=save_result, save_path=computed_feature_saving_path,
            recompute=recompute,  load_path=computed_feature_saving_path
            )
        print("End.")

    if labels is None or features is None:
        print("Extraction of pregenerated labels somehow failed...")
        print("Computing both labels and features from csv!")
        labels, features = extract_label_and_feature_from_csv(
            filepath=csv_path, pose=pose, clf_path=clf_sav_path, fps=fps,
            brute_thresholding=brute_thresholding, threshold=threshold, 
            save_result=save_result, save_path=computed_feature_saving_path,
            recompute=recompute, load_path=computed_feature_saving_path)
        print("End.")
    
    return labels, features

def do_feature_extraction_from_multiple_folders(
        csv_holding_folders : List[str],
        predictions_path : str,
        clf_sav_path : str,
        computed_feature_saving_path : str,
        fps : int=40,
        brute_thresholding : bool=False, 
        threshold : float=0.8,                  
        recompute : bool=False,
        save_result : bool=True,
        pose : List[int]=POSE
        ):
    """
    Execute feature extraction on a set csvs, all contained in of folders & csvs.

    :param list csv_holding_folders: A list of paths to csv-holding
    directories.
    :param str predictions_path: Path to predictions file generated by
    a B-SOID network.
    :param str clf_sav_path: Path to a B-SOID random forest classifier
    we use to extract features. 
    :param str computed_feature_saving_path: Path to where we save the 
    computed features & labels & csv. 
    :param int fps: Frame per second used to record the csv_path file, default=40.
    :param bool brute_thresholding: Whether to use brute thresholding when filtering for
    extracted B-SOID features. Only guaranteed if recompute is True, and defauls to false.
    :param float threshold: Threshold when brute thresholding is done. Only guaranteed 
    if recompute is True, and defaults to 0.8.
    :param bool recompute: Whether to recompute if prior results are found, default=False.
    :param bool save_result: Whether to save computation results, default=True.
    :param List[int] pose: List of column index to extract from dlc csv. Often extract
    num_bodypart x 3 (x,y,likelihood) values . Defaults to POSE, every body part but belly.

    :returns List[Tuple[np.ndarray, np.ndarray]] label_N_features: The labels & features 
    extracted from the folders, as tuples: (labels, features), and in order of extraction.
    """
    label_N_features = []

    for csv_holding_fldr in csv_holding_folders:
        print(f"Processing folder: {os.path.basename(csv_holding_fldr)}!")
        
        for filepath in os.listdir(csv_holding_fldr):
            if not filepath.endswith('.csv'): continue
            print(f"- {filepath} ... ")
            csvpath = os.path.join(csv_holding_fldr, filepath)
        
            label, feature = do_feature_extraction(csv_path=csvpath, 
                                                    predictions_path=predictions_path,
                                                    clf_sav_path=clf_sav_path, 
                                                    computed_feature_saving_path=computed_feature_saving_path, 
                                                    fps=fps,
                                                    brute_thresholding=brute_thresholding,
                                                    threshold=threshold,
                                                    recompute=recompute, 
                                                    save_result=save_result,
                                                    pose=pose)
            
            label_N_features.append((label, feature))

    return label_N_features
        
if __name__ == "__main__":
    def convert_to_current_file_drive(path : str):
        """
        Converts a given path so that its drive points to the same one
        as the drive this file is contained in.
        Used because it's annoying that between my laptop and NINC computers,
        the NINC drive is mounted with different names.
        """
        if path is None: return None
        current_drive, _ = os.path.splitdrive(os.path.abspath(__file__))
        _, remaining_path = os.path.splitdrive(path)
        return os.path.join(current_drive, remaining_path)

    CLFPATH = r"X:\Raymond Lab\2 Colour D1 D2 Photometry Project\Akira\BSOID\Q175\Apr082024\output\Apr-08-2024_randomforest.sav"

    SAVEPATH = r"X:\Raymond Lab\2 Colour D1 D2 Photometry Project\Akira\BSOID\feats_labels"

    PREDICTIONS_PATH = None #r"Z:\Raymond Lab\2 Colour D1 D2 Photometry Project\Akira\BSOID_data\Q175\Apr082024\output"

    # if running on a bunch of csvs in the given folder
    CSV_HOLDING_FOLDERS = [
        r"Z:\Raymond Lab\2 Colour D1 D2 Photometry Project\Akira\DLC\Q175\csv\found_by_script_csvs\it6-2500k"
    ]

    
    # convert everything to the right file drive
    CLFPATH = convert_to_current_file_drive(CLFPATH)
    SAVEPATH = convert_to_current_file_drive(SAVEPATH)
    PREDICTIONS_PATH = convert_to_current_file_drive(PREDICTIONS_PATH)
    CSV_HOLDING_FOLDERS = [convert_to_current_file_drive(file) for file in CSV_HOLDING_FOLDERS]

    # do the extraction
    do_feature_extraction_from_multiple_folders(
        csv_holding_folders=CSV_HOLDING_FOLDERS, 
        predictions_path=PREDICTIONS_PATH, 
        clf_sav_path=CLFPATH, 
        computed_feature_saving_path=SAVEPATH,
        fps=40, 
        brute_thresholding=False, 
        threshold=0.8, 
        recompute=False, 
        save_result=True, 
        pose=POSE
    )